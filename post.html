<!doctype html>
<html lang="en" data-theme="">
  <head>
    <meta charset="utf-8">
    <title>post</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="color-scheme" content="light dark">
    <style>
      :root { --bg:#fff; --fg:#111; --link:#005bff; --accent:#ccc; }
      @media (prefers-color-scheme: dark) {
        :root { --bg:#000; --fg:#fff; --link:#8fc9ed; --accent:#333; }
      }
      [data-theme="dark"] { --bg:#000; --fg:#fff; --link:#8fc9ed; --accent:#333; }
      html,body{height:100%}
      body{margin:0;background:var(--bg);color:var(--fg);font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,"Liberation Mono",monospace;line-height:1.4;-webkit-font-smoothing:antialiased;padding:16px;}
      a,a:visited{color:var(--link);text-decoration:none}
      a:hover{text-decoration:underline}
      .err{color:#d33;white-space:pre-wrap}
      pre{margin:0;white-space:pre-wrap;word-wrap:break-word}
    </style>
  </head>
  <body>
    <pre id="content">Loadingâ€¦</pre>

    <script>
      // Theme: saved choice or system default
      (function () {
        const KEY = "tc-theme";
        const root = document.documentElement;
        let theme = null;
        try {
          const saved = localStorage.getItem(KEY);
          if (saved === "dark" || saved === "light") theme = saved;
        } catch (_) {}
        if (!theme) theme = matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
        root.setAttribute("data-theme", theme);
      }());

      // Load .txt and render with minimal linkify
      (function () {
        const out = document.getElementById("content");
        const params = new URLSearchParams(location.search);
        const path = params.get("p");
        if (!path) { out.textContent = "Missing ?p=relative/path/to/file.txt"; out.className = "err"; return; }

        document.title = path.split("/").pop() || "post";

        fetch(path, { cache: "no-store" })
          .then(r => { if (!r.ok) throw new Error("HTTP " + r.status); return r.text(); })
          .then(text => {
            // Title from first line if short
            const firstLine = (text.split("\n")[0] || "").trim();
            if (firstLine && firstLine.length <= 120) document.title = firstLine.replace(/^#\s*/, "");

            // 1) Escape HTML
            let html = text.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;");

            // 2) Clean common pasted junk (' target="_blank" rel="noopener" or '"> fragments)
            html = html.replace(/\s*target="_blank"\s*rel="noopener"/g, "");
            html = html.replace(/"&gt;/g, "");

            // 3) Markdown links: [label](https?:...)
            const mdLink = /\[([^\]]+)\]\((https?:\/\/[^\s)]+)\)/g;
            html = html.replace(mdLink, (_, label, url) =>
              `<a href="${url}" target="_blank" rel="noopener">${label}</a>`
            );

            // 4) Angle-bracket autolinks: <https://url>
            const angle = /&lt;(https?:\/\/[^&\s>]+)&gt;/g;
            html = html.replace(angle, (_, url) =>
              `<a href="${url}" target="_blank" rel="noopener">${url}</a>`
            );

            // 5) Bare URLs, but ONLY at text boundaries (not inside href="")
            //    Preceder must be start, space, '(', '>', or ';'
            const bare = /(^|[\s>(;])((https?:\/\/[^\s<>"')]+))/g;
            html = html.replace(bare, (m, pre, url) =>
              `${pre}<a href="${url}" target="_blank" rel="noopener">${url}</a>`
            );

            out.innerHTML = html;
          })
          .catch(err => { out.textContent = "Failed to load " + path + "\n" + err; out.className = "err"; });
      }());
    </script>
  </body>
</html>
